# Type definitions (nodes and edges)
node Person {
    label: "<Person>";
}

edge relates_to {
    label: "relates to";
}

# Instantiations
Godrick: Person; # Simply uses all parameters of Person, + 
Malenia: Person {
    label: "overrides type\npart of label";
}

Mellicent: Person {}


# Relationships



# Groups
group Enemies {
    # List of instances.
}

group NPCs {
    # List of instances
}

NPCs can_be Enemies;

# Layers
layer mandatory {
    # List of instances
    # TBD: specify relationships as well? Otherwise we'll provide all edges regardless of their nature.
    #      can be solved by having relationships defined within this scope
}

-------------------------
# TODO: 

# TODO: Separate between type-label and instance-label?
# TODO: Comment # being first non-white character, or after ;? Or solve with unique seq (//)?

Statement-types:

Definitions - contains a set ({}) with parameters and possibly sub-definitions.
node,edge,group,layer
group can contain

TODO: scoping of names: shall we require instantiations within group and layer? Or let groups and layers simply be a list of unique identifiers? How do we then scope names? And how to describe relationships between items of different groups? Suggest requiring name of item be globally unique, but utilize label to simplify.

Naming for all types is global, so conventions must be implemented if there are collisions.
A statement is a definition or a group, or a definition with an associated group (usually to override certain parts of the base edge or node).

group Components {
    group LibComponents {
        LibCompA: Component;
        LibCompB: Component;
    };
    
    group ApiComponents {
        ApiCompA: Component;
        ApiCompB: Component;
    };

    ApiComponents uses LibComponents;

    ApiCompA uses LibCompA;
    ApiCompA uses LibCompB;
};


Token-variants:
a) decl: node|edge|layer|group <identifier> [<attrset>];
b) instant: <identifier>:<identifier:node> [<attrset>];
c) rel: <identifier:instant|group> <identifier:edge> <identifier:instant|group> [<attrset>];

all statements are separated by ; (TBD: can we utilize line-change or brackets where this is natural?)

attrset: {
    <identifier>: <value>;
    decl
    instant
    rel
}


Tokanized: 

Data-structure


Når vi parser så er det et par vesentlige forskjeller:
relationships kan lagres separat da de baserer seg på de globale IDene til elementene
alt skal resolves "lazy", dvs at rekkefølge på def/bruk ikke skal bety noe - dvs vi kommer til å ha dinglende referanser under parsing som må evalueres til slutt
vi må ta vare på kilde-referanse til hver token ifm feilmeldinger


token-types:
keywords: keyword_node, keyword_edge, keyword_group, keyword_layer
symbols: bracket_open, bracket_close, colon, eos (end-of-statement = ;), newline?, quote_start, quote_end
everything else: identifier (kan be left and right-side), later parsing will evaluate and further convert this to e.g. fields and values

Sequence:
* read file
* tokenize (no validation)
* tokens to IF - initial validation/opt-out for invalid sequences
* validate IF - validate deeper 
* IF to output format (.dot, .png, ...)



values-types:
    * integers
        * 400
    * value-keywords/strings (unquoted-singleword vs quoted)
        * #aabbcc
        * green
        * "my name here"
    * scalars: integer+unit
        * 400px
    * parsing: a value starts after first non-ws character after colon. If unquoted: lasts until first ws or ;. If quoted: lasts until next unescaped quote. TODO: Enable escaped quotes - at least at output step unless we start allocating data.

parse-strategies:
* whitespace is collapsed and serve as separator except when inside quotes.
* kommentarer ignoreres (fra kommentar-tegn-start t.o.m eol)
* parser må ta standpunkt til key/value-side av : mtp parsing av keywords

strings:
* quoted or single-word (starts with a-zA-Z)

TODO: How to define top-level properties of the diagram?
* Title
* Dimensions
* Diagram/layout-type
* Overall color-scheme
Proposal: a "magic" diagram-definitions allowed at top-level
Alternative: Provide as input-arguments to the compilator


Problem: vi benytter nå kolon til to ulike ting: type-angivelse ved instansiering, og verdi-tilordning. Innføre = isteden for sistnevnte?